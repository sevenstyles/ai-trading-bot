//@version=6
indicator("Swing Structure", overlay=true, max_labels_count=500, max_lines_count=500)

// Constants
var BULLISH = 1
var BEARISH = -1
var BULLISH_LEG = 1
var BEARISH_LEG = 0

// Variables to store previous swing levels and market structure
var float prevSwingHigh = na
var float prevSwingLow = na
var float lastSwingHigh = na
var float lastSwingLow = na
var bool inDowntrend = false
var bool inUptrend = false
var int lastSwingHighBar = na
var int lastSwingLowBar = na
var int trendBias = 0

// Initialize all boolean flags at the start
var bool hasHigherLow = false
var bool hasLowerHigh = false
var bool validBosPattern = false
var bool bosConfirmationUp = false
var bool bosConfirmationDown = false
var bool trendContinuationUp = false
var bool trendContinuationDown = false

// Initialize arrays at the start
var array<line> bosLines = array.new<line>()
var array<label> swingLabels = array.new<label>()
var float[] recentSwingHighs = array.new_float(3, na)
var float[] recentSwingLows = array.new_float(3, na)
var int[] recentSwingHighBars = array.new_int(3, na)
var int[] recentSwingLowBars = array.new_int(3, na)
var string[] patternHistory = array.new_string(3, "")  // Store last 3 swing patterns
var int lastPatternBar = 0  // Store the bar index of last pattern update

// Initialize other variables
var float lastBosLevel = na
var int lastBosBar = na
var float lastSignificantHigh = na
var float lastSignificantLow = na
var int lastSignificantHighBar = na
var int lastSignificantLowBar = na
var int consecutiveHigher = 0
var int consecutiveLower = 0

// Input parameters with more sensitive defaults
lookbackLeft = input(5, "Lookback Left (Major Swings)")
lookbackRight = input(3, "Lookback Right (Major Swings)")
minorLookbackLeft = input(3, "Lookback Left (Minor Swings)")
minorLookbackRight = input(2, "Lookback Right (Minor Swings)")
labelOffset = input.float(0.5, "Text Offset %", minval=0.1, step=0.1) / 100
swingThreshold = input.float(0.2, "Swing Threshold %", minval=0.1, step=0.1) / 100
atrPeriod = input(10, "ATR Period")
atrMultiplier = input.float(1.0, "ATR Multiplier for Swing Significance", minval=0.5, step=0.1)
textSize = input.string("Small", "Text Size", options=["Tiny", "Small", "Normal", "Large"])

// More sensitive swing detection - moved up before first usage
float threshold = math.min(ta.atr(atrPeriod) * atrMultiplier, close * swingThreshold)

// Text size mapping
textSizeValue = switch textSize
    "Tiny" => size.tiny
    "Small" => size.small
    "Normal" => size.normal
    => size.large

// Pre-calculate values for consistency
var float sma20 = na
sma20 := ta.sma(close, 20)
var bool crossUnderSma = false
var bool crossOverSma = false
crossUnderSma := ta.crossunder(close, sma20)
crossOverSma := ta.crossover(close, sma20)

// Calculate dynamic offset based on ATR
var float dynamicOffset = na
dynamicOffset := math.max(ta.atr(atrPeriod) * labelOffset, high - low)

// Major swing points with more frequent detection
swingHigh = ta.pivothigh(high, lookbackLeft, lookbackRight)
swingLow = ta.pivotlow(low, lookbackLeft, lookbackRight)

// Minor swing points for confirmation
minorSwingHigh = ta.pivothigh(high, minorLookbackLeft, minorLookbackRight)
minorSwingLow = ta.pivotlow(low, minorLookbackLeft, minorLookbackRight)

// Enhanced validation without volume
bool validSwingHigh = not na(swingHigh) and (na(lastSwingHigh) or math.abs(swingHigh - lastSwingHigh) > threshold)
bool validSwingLow = not na(swingLow) and (na(lastSwingLow) or math.abs(swingLow - lastSwingLow) > threshold)

// More sensitive minor swing detection
bool validMinorSwingHigh = not na(minorSwingHigh) and (na(lastSwingHigh) or math.abs(minorSwingHigh - lastSwingHigh) > threshold * 0.5)
bool validMinorSwingLow = not na(minorSwingLow) and (na(lastSwingLow) or math.abs(minorSwingLow - lastSwingLow) > threshold * 0.5)

// Enhanced trend change detection
bool significantMove = math.abs(close - close[1]) > threshold

// Improved BOS detection - moved up
bool validBosUp = validSwingLow and low[lookbackRight] > lastSwingLow and significantMove
bool validBosDown = validSwingHigh and high[lookbackRight] < lastSwingHigh and significantMove

// Pattern Sequence Settings
showPatternOne = input.bool(true, "Show HH->HL->BOS Pattern", group="Pattern Sequences")
patternOneColor = input.color(color.green, "HH->HL->BOS Pattern Color", group="Pattern Sequences")
showPatternTwo = input.bool(true, "Show LL->LH->BOS Pattern", group="Pattern Sequences")
patternTwoColor = input.color(color.blue, "LL->LH->BOS Pattern Color", group="Pattern Sequences")

// Pattern Detection with debug info
var label debugLabel = na
var bool lastWasHH = false
var bool lastWasHL = false
var bool lastWasLL = false
var bool lastWasLH = false
var bool waitingForBullishBOS = false
var bool waitingForBearishBOS = false

// Function to get pattern history as string
getPatternHistoryString() =>
    result = ""
    for i = 0 to 2
        pattern = array.get(patternHistory, i)
        result := result + (i == 0 ? "" : "->") + pattern
    result

// Function to update pattern history and return the current bar index
updatePatternHistory(string pattern) =>
    array.unshift(patternHistory, pattern)
    array.pop(patternHistory)
    bar_index

// Enhanced pattern detection with state tracking
bool patternOneDetected = false  // HH->HL->BOS
bool patternTwoDetected = false  // LL->LH->BOS

// Update pattern history based on swing formations
if validSwingHigh and not na(prevSwingHigh)
    if high[lookbackRight] > prevSwingHigh
        lastPatternBar := updatePatternHistory("HH")
        lastWasHH := true
        lastWasHL := false
        lastWasLL := false
        lastWasLH := false
        if lastWasHL
            waitingForBullishBOS := true
    else
        lastPatternBar := updatePatternHistory("LH")
        lastWasLH := true
        lastWasHH := false
        lastWasHL := false
        lastWasLL := false
        if lastWasLL
            waitingForBearishBOS := true

if validSwingLow and not na(prevSwingLow)
    if low[lookbackRight] < prevSwingLow
        lastPatternBar := updatePatternHistory("LL")
        lastWasLL := true
        lastWasHH := false
        lastWasHL := false
        lastWasLH := false
        if lastWasLH
            waitingForBearishBOS := true
    else
        lastPatternBar := updatePatternHistory("HL")
        lastWasHL := true
        lastWasHH := false
        lastWasLL := false
        lastWasLH := false
        if lastWasHH
            waitingForBullishBOS := true

// Update BOS patterns more explicitly
if validBosUp and waitingForBullishBOS
    lastPatternBar := updatePatternHistory("BOS_UP")
    patternOneDetected := true
    waitingForBullishBOS := false
    label.new(bar_index, low - (2 * dynamicOffset), text="BOS_UP", 
             style=label.style_label_up, color=color.new(patternOneColor, 40), 
             textcolor=patternOneColor, size=size.normal)
    
if validBosDown and waitingForBearishBOS
    lastPatternBar := updatePatternHistory("BOS_DOWN")
    patternTwoDetected := true
    waitingForBearishBOS := false
    label.new(bar_index, high + (2 * dynamicOffset), text="BOS_DOWN", 
             style=label.style_label_down, color=color.new(patternTwoColor, 40), 
             textcolor=patternTwoColor, size=size.normal)

// Reset pattern flags when conditions are broken
if validSwingHigh or validSwingLow
    if not (lastWasHH or lastWasHL)
        waitingForBullishBOS := false
        patternOneDetected := false
    if not (lastWasLL or lastWasLH)
        waitingForBearishBOS := false
        patternTwoDetected := false

// Plot pattern signals with larger size for visibility
plotshape(patternOneDetected, title="HH->HL->BOS Pattern", location=location.belowbar, 
          color=patternOneColor, style=shape.triangleup, size=size.huge)
plotshape(patternTwoDetected, title="LL->LH->BOS Pattern", location=location.abovebar, 
          color=patternTwoColor, style=shape.triangledown, size=size.huge)

// Add pattern labels for clarity with increased visibility
if patternOneDetected
    label.new(bar_index, low - (3 * dynamicOffset), text="HH->HL->BOS", 
              style=label.style_label_up, color=color.new(patternOneColor, 40), 
              textcolor=patternOneColor, size=size.large)

if patternTwoDetected
    label.new(bar_index, high + (3 * dynamicOffset), text="LL->LH->BOS", 
              style=label.style_label_down, color=color.new(patternTwoColor, 40), 
              textcolor=patternTwoColor, size=size.large)

// Enhanced leg detection
getLeg(int size) =>
    var leg = 0    
    newLegHigh = high[size] > ta.highest(high, size)
    newLegLow = low[size] < ta.lowest(low, size)
    
    if newLegHigh
        leg := BEARISH_LEG
    else if newLegLow
        leg := BULLISH_LEG
    leg

// Detect start of new leg
isNewLeg(int leg) => ta.change(leg) != 0
isBearishLeg(int leg) => ta.change(leg) == -1
isBullishLeg(int leg) => ta.change(leg) == 1

// Higher lows and lower highs detection
hasHigherLow := validSwingLow and (na(lastSwingLow) or low[lookbackRight] > lastSwingLow)
hasLowerHigh := validSwingHigh and (na(lastSwingHigh) or high[lookbackRight] < lastSwingHigh)

// Enhanced swing pattern detection
updateRecentSwings() =>
    if validSwingHigh
        array.unshift(recentSwingHighs, high[lookbackRight])
        array.unshift(recentSwingHighBars, bar_index[lookbackRight])
        array.pop(recentSwingHighs)
        array.pop(recentSwingHighBars)
    
    if validSwingLow
        array.unshift(recentSwingLows, low[lookbackRight])
        array.unshift(recentSwingLowBars, bar_index[lookbackRight])
        array.pop(recentSwingLows)
        array.pop(recentSwingLowBars)

updateRecentSwings()

// Track consecutive swings for trend strength
if validSwingHigh
    if high[lookbackRight] > lastSwingHigh
        consecutiveHigher := consecutiveHigher + 1
        consecutiveLower := 0
    else if high[lookbackRight] < lastSwingHigh
        consecutiveHigher := 0
        consecutiveLower := consecutiveLower + 1

if validSwingLow
    if low[lookbackRight] > lastSwingLow
        consecutiveHigher := consecutiveHigher + 1
        consecutiveLower := 0
    else if low[lookbackRight] < lastSwingLow
        consecutiveHigher := 0
        consecutiveLower := consecutiveLower + 1

// Break of Structure confirmation
bosConfirmationUp := (validBosUp and close > sma20 and validMinorSwingLow and minorSwingLow > lastSwingLow)
bosConfirmationDown := (validBosDown and close < sma20 and validMinorSwingHigh and minorSwingHigh < lastSwingHigh)

// Track the last significant swing levels for BOS
if validSwingHigh
    lastSignificantHigh := high[lookbackRight]
    lastSignificantHighBar := bar_index[lookbackRight]

if validSwingLow
    lastSignificantLow := low[lookbackRight]
    lastSignificantLowBar := bar_index[lookbackRight]

// Check for BOS and draw horizontal lines
if not na(lastSignificantLow) and low < lastSignificantLow and inDowntrend
    line.new(lastSignificantLowBar, lastSignificantLow, bar_index, lastSignificantLow, color=color.fuchsia, width=2)
    label.new(bar_index, lastSignificantLow, text="BOS", xloc=xloc.bar_index, yloc=yloc.price, 
             color=na, textcolor=color.fuchsia, style=label.style_label_up, size=textSizeValue)
    lastSignificantLow := na  // Reset to avoid multiple lines

if not na(lastSignificantHigh) and high > lastSignificantHigh and inUptrend
    line.new(lastSignificantHighBar, lastSignificantHigh, bar_index, lastSignificantHigh, color=color.fuchsia, width=2)
    label.new(bar_index, lastSignificantHigh, text="BOS", xloc=xloc.bar_index, yloc=yloc.price, 
             color=na, textcolor=color.fuchsia, style=label.style_label_down, size=textSizeValue)
    lastSignificantHigh := na  // Reset to avoid multiple lines

// Trend continuation conditions
trendContinuationUp := (consecutiveHigher >= 2 and validMinorSwingLow and minorSwingLow > lastSwingLow and close > sma20)
trendContinuationDown := (consecutiveLower >= 2 and validMinorSwingHigh and minorSwingHigh < lastSwingHigh and close < sma20)

// Update swing points and plot text with improved BOS visualization
if validSwingHigh
    float swingHighPrice = swingHigh
    lastSwingHigh := swingHighPrice
    
    if not na(prevSwingHigh)
        if swingHighPrice > prevSwingHigh
            label.new(bar_index[lookbackRight], swingHighPrice + dynamicOffset, text="HH", xloc=xloc.bar_index, yloc=yloc.price, color=na, textcolor=color.green, style=label.style_label_down, size=textSizeValue)
            if inDowntrend
                label.new(bar_index[lookbackRight], swingHighPrice + (2 * dynamicOffset), text="BOS", xloc=xloc.bar_index, yloc=yloc.price, color=na, textcolor=color.purple, style=label.style_label_down, size=textSizeValue)
                line.new(bar_index[lookbackRight], close[lookbackRight], lastSwingHighBar, prevSwingHigh, color=color.yellow, width=2)
                inDowntrend := false
                inUptrend := true
                trendBias := BULLISH
        else
            label.new(bar_index[lookbackRight], swingHighPrice + dynamicOffset, text="LH", xloc=xloc.bar_index, yloc=yloc.price, color=na, textcolor=color.orange, style=label.style_label_down, size=textSizeValue)
            if not inDowntrend
                inDowntrend := true
                inUptrend := false
                trendBias := BEARISH
    prevSwingHigh := swingHighPrice
    lastSwingHighBar := bar_index[lookbackRight]

if validSwingLow
    float swingLowPrice = swingLow
    lastSwingLow := swingLowPrice
    
    if not na(prevSwingLow)
        if swingLowPrice < prevSwingLow
            label.new(bar_index[lookbackRight], swingLowPrice - dynamicOffset, text="LL", xloc=xloc.bar_index, yloc=yloc.price, color=na, textcolor=color.red, style=label.style_label_up, size=textSizeValue)
            if inUptrend
                label.new(bar_index[lookbackRight], swingLowPrice - (2 * dynamicOffset), text="BOS", xloc=xloc.bar_index, yloc=yloc.price, color=na, textcolor=color.purple, style=label.style_label_up, size=textSizeValue)
                line.new(bar_index[lookbackRight], close[lookbackRight], lastSwingLowBar, prevSwingLow, color=color.yellow, width=2)
                inUptrend := false
                inDowntrend := true
                trendBias := BEARISH
        else
            label.new(bar_index[lookbackRight], swingLowPrice - dynamicOffset, text="HL", xloc=xloc.bar_index, yloc=yloc.price, color=na, textcolor=color.green, style=label.style_label_up, size=textSizeValue)
            if not inUptrend
                inUptrend := true
                inDowntrend := false
                trendBias := BULLISH
    prevSwingLow := swingLowPrice
    lastSwingLowBar := bar_index[lookbackRight] 

// Track the last BOS level and bar
if validBosUp or validBosDown
    lastBosLevel := validBosUp ? lastSwingLow : lastSwingHigh
    lastBosBar := bar_index[lookbackRight]

// Detect valid structure patterns after BOS
if not na(lastBosLevel) and not na(lastBosBar)
    barsFromBos = bar_index - lastBosBar
    if barsFromBos <= lookbackLeft * 3  // Extended range for pattern completion
        if validBosUp and inUptrend
            // Bullish structure pattern
            validBosPattern := validMinorSwingLow and minorSwingLow > lastBosLevel and close > sma20 and hasHigherLow and array.get(recentSwingLows, 0) > array.get(recentSwingLows, 1)
        else if validBosDown and inDowntrend
            // Bearish structure pattern
            validBosPattern := validMinorSwingHigh and minorSwingHigh < lastBosLevel and close < sma20 and hasLowerHigh and array.get(recentSwingHighs, 0) < array.get(recentSwingHighs, 1) 