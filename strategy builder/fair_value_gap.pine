// © Sevenstyles

//@version=5
indicator(title="Fair Value Gaps", shorttitle="FVG", overlay=true, max_boxes_count = 200)

// Trend Strength Settings
trend_lookback = input.int(100, "Trend Strength Lookback", minval=10, maxval=1000, group="Trend Strength Settings", tooltip="Number of bars to analyze for trend strength")
trend_label_color = input.color(defval = color.new(color.white, 0), title = "Trend Label Text Color", group = "Trend Strength Settings")
trend_label_size = input.string("large", "Trend Label Size", options=["tiny", "small", "normal", "large"], group="Trend Strength Settings")
trend_label_position = input.string("top right", "Label Position", options=["top right", "top left", "bottom right", "bottom left"], group="Trend Strength Settings")

// Validation Settings
volume_lookback = input.int(20, "Volume Average Lookback", minval=5, maxval=50, group="Validation Settings")
atr_lookback = input.int(14, "ATR Lookback", minval=5, maxval=50, group="Validation Settings")

// Color Settings
upcolor = input.color(defval = color.new(color.green, 77), title = "Bullish FVG color", group = "Aesthetics")
downcolor = input.color(defval = color.new(color.red, 77), title = "Bearish FVG color", group = "Aesthetics")
consecutive_upcolor = input.color(defval = color.new(color.blue, 77), title = "Consecutive Bullish FVG color", group = "Aesthetics")
consecutive_downcolor = input.color(defval = color.new(color.purple, 77), title = "Consecutive Bearish FVG color", group = "Aesthetics")
ob_up_color = input.color(defval = color.new(color.green, 85), title = "Bullish Order Block color", group = "Aesthetics")
ob_down_color = input.color(defval = color.new(color.red, 85), title = "Bearish Order Block color", group = "Aesthetics")

// Volume Display Settings
show_box_volume = input.bool(false, "Show Volume in FVG Boxes", group="Volume Settings")

// Consecutive FVG Settings
use_consecutive = input.bool(true, "Filter for Consecutive FVGs", group="Consecutive FVG Filter")
required_consecutive = input.int(2, "Required Consecutive FVGs", minval=2, maxval=5, group="Consecutive FVG Filter", tooltip="Only show FVGs when this many consecutive FVGs of the same type (bullish/bearish) have occurred")
highlight_consecutive = input.bool(true, "Highlight Consecutive FVGs", group="Consecutive FVG Filter")

// Order Block Settings
show_order_blocks = input.bool(true, "Show Order Blocks", group="Order Block Settings")

// Strong FVG Settings
strong_fvg_bars = input.int(30, "Strong FVG Bars", minval=5, maxval=100, group="Strong FVG Settings", tooltip="Number of bars before an FVG is considered strong")
strong_bullish_line_color = input.color(defval = color.new(color.yellow, 0), title = "Strong Bullish FVG Line Color", group = "Strong FVG Settings")
strong_bearish_line_color = input.color(defval = color.new(color.orange, 0), title = "Strong Bearish FVG Line Color", group = "Strong FVG Settings")
strong_fvg_line_width = input.int(2, "Strong FVG Line Width", minval=1, maxval=4, group="Strong FVG Settings")
strong_fvg_line_style = input.string("solid", "Strong FVG Line Style", options=["solid", "dashed", "dotted"], group="Strong FVG Settings")
max_strong_lines = input.int(50, "Maximum Strong FVG Lines", minval=1, maxval=100, group="Strong FVG Settings")

// Score Weights
float DISTRIBUTION_WEIGHT = 0.3
float VOLUME_WEIGHT = 0.25
float STRENGTH_WEIGHT = 0.25
float GAP_WEIGHT = 0.2

// Function to calculate weighted score
calculate_score(fvg_percent, vol_percent, strength_percent, gap_size) =>
    float distribution_score = fvg_percent / 100
    float volume_score = vol_percent / 100
    float strength_score = math.min(strength_percent / 150, 1.0)  // Cap at 150%
    float gap_score = math.min(gap_size / 100, 1.0)  // Cap at 100% of ATR
    
    float total_score = 0.0
    total_score := (distribution_score * DISTRIBUTION_WEIGHT) +
                   (volume_score * VOLUME_WEIGHT) +
                   (strength_score * STRENGTH_WEIGHT) +
                   (gap_score * GAP_WEIGHT)
    total_score

// Function to get color based on value
get_value_color(value, neutral_threshold, good_threshold) =>
    value <= neutral_threshold ? color.red : 
         value >= good_threshold ? color.green : 
         color.yellow

// Function to format percentage with color
format_percent(value, neutral_threshold, good_threshold) =>
    color_code = get_value_color(value, neutral_threshold, good_threshold)
    color_str = color_code == color.red ? "🔴" : 
         color_code == color.green ? "🟢" : "🟡"
    color_str + " " + str.tostring(value, "#.#") + "%"

// Signal Settings
signal_distribution_threshold = input.float(65, "Distribution % Threshold", minval=50, maxval=90, group="Signal Settings")
signal_volume_threshold = input.float(60, "Volume % Threshold", minval=50, maxval=90, group="Signal Settings")
signal_strength_threshold = input.float(110, "Volume Strength % Threshold", minval=100, maxval=150, group="Signal Settings")
signal_gap_threshold = input.float(50, "Gap Size % Threshold", minval=30, maxval=100, group="Signal Settings")

// Arrays to store boxes and their levels
var box[] bullishBoxes = array.new_box()
var float[] bullishTops = array.new_float()
var float[] bullishBottoms = array.new_float()
var box[] bearishBoxes = array.new_box()
var float[] bearishTops = array.new_float()
var float[] bearishBottoms = array.new_float()
var box[] orderBlockBoxes = array.new_box()  // Array to store order block boxes

// Arrays to store FVG creation times and lines
var int[] bullishFVGStartBars = array.new_int()
var int[] bearishFVGStartBars = array.new_int()
var line[] bullishStrongLines = array.new_line()  // Separate arrays for bullish and bearish lines
var line[] bearishStrongLines = array.new_line()
var int[] bullishLineIndices = array.new_int()  // Separate indices for bullish and bearish
var int[] bearishLineIndices = array.new_int()
var bool[] bullishLineCreated = array.new_bool()  // Separate tracking for bullish and bearish
var bool[] bearishLineCreated = array.new_bool()

// Variables to track consecutive FVGs
var int bullishConsecutive = 0
var int bearishConsecutive = 0
var bool lastWasBullish = false
var bool lastWasBearish = false
var bool bfvg = false
var bool sfvg = false
var bool canPlotFVG = false

// Variables for trend strength calculation
var int total_bullish_fvgs = 0
var int total_bearish_fvgs = 0
var label trend_label = na
var int[] filled_bullish_fvgs = array.new_int()  // Track filled FVGs
var int[] filled_bearish_fvgs = array.new_int()  // Track filled FVGs

// Function to check if candle is bullish/bearish
is_bullish_candle(idx) => close[idx] > open[idx]
is_bearish_candle(idx) => close[idx] < open[idx]

// FVG Detection
// Only check for FVG after the current candle has closed
if barstate.isconfirmed
    // Check for bullish FVG
    if low > high[2]  // Check the gap using current candle
        bfvg := true
        canPlotFVG := true
    else
        bfvg := false
    
    // Check for bearish FVG
    if high < low[2]  // Check the gap using current candle
        sfvg := true
        canPlotFVG := true
    else
        sfvg := false
else
    bfvg := false
    sfvg := false
    canPlotFVG := false

// Update consecutive counters with type checking
if bfvg and lastWasBullish
    bullishConsecutive := bullishConsecutive + 1
else if bfvg
    bullishConsecutive := 1
else
    bullishConsecutive := 0

if sfvg and lastWasBearish
    bearishConsecutive := bearishConsecutive + 1
else if sfvg
    bearishConsecutive := 1
else
    bearishConsecutive := 0

// Update last FVG type
lastWasBullish := bfvg
lastWasBearish := sfvg

// Create new FVG boxes only when candle has closed
if canPlotFVG
    if bfvg and (not use_consecutive or bullishConsecutive >= required_consecutive)
        float fvg_top = low
        float fvg_bottom = high[2]
        
        // Calculate volume info
        float current_vol = volume
        float prev_vol = volume[1]
        string vol_text = show_box_volume ? "Vol: " + str.tostring(current_vol, "#.#") + "\nPrev: " + str.tostring(prev_vol, "#.#") : ""
        
        color boxColor = highlight_consecutive and bullishConsecutive >= required_consecutive ? consecutive_upcolor : upcolor
        box newBox = box.new(left=bar_index-2, top=fvg_top, right=bar_index+10, bottom=fvg_bottom,
             border_color=color.new(color.gray, 100), bgcolor=boxColor,
             text=vol_text,
             text_size=size.small,
             text_color=color.new(color.white, 0),
             text_halign=text.align_center,
             text_valign=text.align_center)
        array.push(bullishBoxes, newBox)
        array.push(bullishTops, fvg_top)
        array.push(bullishBottoms, fvg_bottom)
        array.push(bullishFVGStartBars, bar_index)
        array.push(bullishLineCreated, false)  // Use bullish tracking array

        // Add order block for bullish FVG
        if show_order_blocks
            box obBox = box.new(left=bar_index-2, top=high[2], right=bar_index-1, bottom=low[2],
                 border_color=color.new(color.gray, 100), bgcolor=ob_up_color)
            array.push(orderBlockBoxes, obBox)

    if sfvg and (not use_consecutive or bearishConsecutive >= required_consecutive)
        float fvg_top = low[2]  // This is actually the top of the gap
        float fvg_bottom = high  // This is the bottom of the gap
        
        // Calculate volume info for bearish FVG
        float current_vol = volume
        float prev_vol = volume[1]
        string vol_text = show_box_volume ? "Vol: " + str.tostring(current_vol, "#.#") + "\nPrev: " + str.tostring(prev_vol, "#.#") : ""
        
        color boxColor = highlight_consecutive and bearishConsecutive >= required_consecutive ? consecutive_downcolor : downcolor
        box newBox = box.new(left=bar_index-2, top=fvg_top, right=bar_index+10, bottom=fvg_bottom,
             border_color=color.new(color.gray, 100), bgcolor=boxColor,
             text=vol_text,
             text_size=size.small,
             text_color=color.new(color.white, 0),
             text_halign=text.align_center,
             text_valign=text.align_center)
        array.push(bearishBoxes, newBox)
        array.push(bearishTops, fvg_top)  // Store the actual top of the gap
        array.push(bearishBottoms, fvg_bottom)
        array.push(bearishFVGStartBars, bar_index)
        array.push(bearishLineCreated, false)

        // Add order block for bearish FVG
        if show_order_blocks
            box obBox = box.new(left=bar_index-2, top=high[2], right=bar_index-1, bottom=low[2],
                 border_color=color.new(color.gray, 100), bgcolor=ob_down_color)
            array.push(orderBlockBoxes, obBox)

// Modify box removal sections
// In bullish box removal:
if array.size(bullishBoxes) > 0 and barstate.isconfirmed
    for i = array.size(bullishBoxes) - 1 to 0
        box currentBox = array.get(bullishBoxes, i)
        float top = array.get(bullishTops, i)
        float bottom = array.get(bullishBottoms, i)
        
        if is_bearish_candle(0) and close < bottom and open < bottom
            box.delete(currentBox)
            array.push(filled_bullish_fvgs, bar_index)  // Track when FVG was filled
            // Find and remove the corresponding line
            int lineIndex = array.indexof(bullishLineIndices, i)
            if lineIndex >= 0 and lineIndex < array.size(bullishStrongLines)
                line oldLine = array.get(bullishStrongLines, lineIndex)
                line.delete(oldLine)
                array.remove(bullishStrongLines, lineIndex)
                array.remove(bullishLineIndices, lineIndex)
            array.remove(bullishBoxes, i)
            array.remove(bullishTops, i)
            array.remove(bullishBottoms, i)
            array.remove(bullishFVGStartBars, i)
            array.remove(bullishLineCreated, i)
        else
            box.set_right(currentBox, bar_index + 10)

// In bearish box removal:
if array.size(bearishBoxes) > 0 and barstate.isconfirmed
    for i = array.size(bearishBoxes) - 1 to 0
        box currentBox = array.get(bearishBoxes, i)
        float top = array.get(bearishTops, i)
        float bottom = array.get(bearishBottoms, i)
        
        if is_bullish_candle(0) and close > top and open > top
            box.delete(currentBox)
            array.push(filled_bearish_fvgs, bar_index)  // Track when FVG was filled
            // Find and remove the corresponding line
            int lineIndex = array.indexof(bearishLineIndices, i)
            if lineIndex >= 0 and lineIndex < array.size(bearishStrongLines)
                line oldLine = array.get(bearishStrongLines, lineIndex)
                line.delete(oldLine)
                array.remove(bearishStrongLines, lineIndex)
                array.remove(bearishLineIndices, lineIndex)
            array.remove(bearishBoxes, i)
            array.remove(bearishTops, i)
            array.remove(bearishBottoms, i)
            array.remove(bearishFVGStartBars, i)
            array.remove(bearishLineCreated, i)
        else
            box.set_right(currentBox, bar_index + 10)

// Clean up old order block boxes
if array.size(orderBlockBoxes) > 200
    box oldBox = array.shift(orderBlockBoxes)
    box.delete(oldBox)

// After the box removal checks, calculate and display trend strength
if barstate.isconfirmed
    // Reset counters
    int bullish_count = 0
    int bearish_count = 0
    float bullish_volume = 0.0
    float bearish_volume = 0.0
    int bullish_filled = 0
    int bearish_filled = 0
    float latest_bull_vol = 0.0
    float latest_bear_vol = 0.0
    bool found_latest_bull = false
    bool found_latest_bear = false
    
    // Calculate average volume and ATR for relative comparisons
    float avg_volume = ta.sma(volume, volume_lookback)
    float atr = ta.atr(atr_lookback)
    
    // Count bullish FVGs and volumes within lookback period
    if array.size(bullishBoxes) > 0
        for i = array.size(bullishBoxes) - 1 to 0
            box currentBox = array.get(bullishBoxes, i)
            int box_left = box.get_left(currentBox)
            if bar_index - box_left <= trend_lookback
                bullish_count += 1
                float curr_vol = volume[bar_index - box_left]
                bullish_volume += curr_vol
                
                // Track latest bullish FVG volume
                if not found_latest_bull
                    latest_bull_vol := curr_vol
                    found_latest_bull := true
                
                // Check if this FVG was filled
                if box.get_right(currentBox) != bar_index + 10  // If right edge isn't at current + 10, it was filled
                    bullish_filled += 1
    
    // Count bearish FVGs and volumes within lookback period
    if array.size(bearishBoxes) > 0
        for i = array.size(bearishBoxes) - 1 to 0
            box currentBox = array.get(bearishBoxes, i)
            int box_left = box.get_left(currentBox)
            if bar_index - box_left <= trend_lookback
                bearish_count += 1
                float curr_vol = volume[bar_index - box_left]
                bearish_volume += curr_vol
                
                // Track latest bearish FVG volume
                if not found_latest_bear
                    latest_bear_vol := curr_vol
                    found_latest_bear := true
                
                // Check if this FVG was filled
                if box.get_right(currentBox) != bar_index + 10  // If right edge isn't at current + 10, it was filled
                    bearish_filled += 1
    
    // Update totals
    total_bullish_fvgs := bullish_count
    total_bearish_fvgs := bearish_count
    
    // Calculate FVG percentages
    float total_fvgs = total_bullish_fvgs + total_bearish_fvgs
    float bullish_percentage = total_fvgs > 0 ? (total_bullish_fvgs / total_fvgs) * 100 : 0
    float bearish_percentage = total_fvgs > 0 ? (total_bearish_fvgs / total_fvgs) * 100 : 0
    
    // Calculate volume percentages
    float total_volume = bullish_volume + bearish_volume
    float bullish_vol_percentage = total_volume > 0 ? (bullish_volume / total_volume) * 100 : 0
    float bearish_vol_percentage = total_volume > 0 ? (bearish_volume / total_volume) * 100 : 0
    
    // Count filled FVGs within lookback period
    int filled_bull_count = 0
    int filled_bear_count = 0
    int total_bull_count = 0
    int total_bear_count = 0
    
    // First, count total FVGs that were created AND completed (either filled or invalidated)
    if array.size(bullishFVGStartBars) > 0
        for i = 0 to array.size(bullishFVGStartBars) - 1
            int start_bar = array.get(bullishFVGStartBars, i)
            if bar_index - start_bar <= trend_lookback
                total_bull_count += 1
    
    if array.size(bearishFVGStartBars) > 0
        for i = 0 to array.size(bearishFVGStartBars) - 1
            int start_bar = array.get(bearishFVGStartBars, i)
            if bar_index - start_bar <= trend_lookback
                total_bear_count += 1
    
    // Then count filled FVGs
    if array.size(filled_bullish_fvgs) > 0
        for i = array.size(filled_bullish_fvgs) - 1 to 0
            int fill_bar = array.get(filled_bullish_fvgs, i)
            if bar_index - fill_bar <= trend_lookback
                filled_bull_count += 1
    
    if array.size(filled_bearish_fvgs) > 0
        for i = array.size(filled_bearish_fvgs) - 1 to 0
            int fill_bar = array.get(filled_bearish_fvgs, i)
            if bar_index - fill_bar <= trend_lookback
                filled_bear_count += 1
    
    // Calculate momentum strength (replaces fill rate)
    float bull_momentum = ta.rma(close > open ? volume : 0, 10) / ta.rma(volume, 10) * 100
    float bear_momentum = ta.rma(close < open ? volume : 0, 10) / ta.rma(volume, 10) * 100

    // Calculate latest FVG metrics
    float latest_bull_vol_strength = found_latest_bull ? (latest_bull_vol / avg_volume) * 100 : 0
    float latest_bear_vol_strength = found_latest_bear ? (latest_bear_vol / avg_volume) * 100 : 0
    
    // Calculate latest gap sizes relative to ATR
    float latest_bull_gap_size = array.size(bullishBoxes) > 0 ? 
         ((array.get(bullishTops, array.size(bullishTops)-1) - array.get(bullishBottoms, array.size(bullishBottoms)-1)) / atr) * 100 : 0
    float latest_bear_gap_size = array.size(bearishBoxes) > 0 ? 
         ((array.get(bearishTops, array.size(bearishTops)-1) - array.get(bearishBottoms, array.size(bearishBottoms)-1)) / atr) * 100 : 0

    // Calculate scores with adjusted weights
    float long_score = calculate_score(bullish_percentage, bullish_vol_percentage, 
         latest_bull_vol_strength, latest_bull_gap_size) * 100
    float short_score = calculate_score(bearish_percentage, bearish_vol_percentage,
         latest_bear_vol_strength, latest_bear_gap_size) * 100

    // Optimized signal conditions based on aligned percentages
    bool long_signal = 
         // All bullish percentages must show strength (green)
         bullish_percentage >= 65 and              // FVG Distribution
         bullish_vol_percentage >= 65 and          // Volume Dominance
         latest_bull_vol_strength >= 150 and       // Volume Strength
         latest_bull_gap_size >= 75 and           // Gap Size
         bull_momentum >= 60                       // Momentum
         
    bool short_signal = 
         // All bearish percentages must show strength (green)
         bearish_percentage >= 65 and              // FVG Distribution
         bearish_vol_percentage >= 65 and          // Volume Dominance
         latest_bear_vol_strength >= 150 and       // Volume Strength
         latest_bear_gap_size >= 75 and           // Gap Size
         bear_momentum >= 60                       // Momentum

    // Plot signals on chart with larger arrows
    if long_signal
        label.new(bar_index, low * 0.999, "⬆", 
             color=color.new(color.black, 100),  // Transparent background
             style=label.style_label_up,
             textcolor=color.new(color.green, 0),
             size=size.huge)                    // Increased size for better visibility
    
    if short_signal
        label.new(bar_index, high * 1.001, "⬇", 
             color=color.new(color.black, 100),  // Transparent background
             style=label.style_label_down,
             textcolor=color.new(color.red, 0),
             size=size.huge)                    // Increased size for better visibility

    // Add signal info to the stats display
    string signal_text = ""
    if long_signal
        signal_text := "\n🎯 STRONG BULLISH ALIGNMENT!"
    if short_signal
        signal_text := signal_text + "\n🎯 STRONG BEARISH ALIGNMENT!"
    
    // Delete old label
    if not na(trend_label)
        label.delete(trend_label)
    
    // Determine label position
    int x_pos = trend_label_position == "top right" or trend_label_position == "bottom right" ? bar_index + 2 : bar_index - 50
    float y_pos = trend_label_position == "top right" or trend_label_position == "top left" ? ta.highest(high, 20) * 1.02 : ta.lowest(low, 20) * 0.98
    
    // Create enhanced label text with improved formatting
    string label_text = "⚡ SIGNAL SCORES ⚡\n" +
                       "LONG: " + format_percent(long_score, 45, 65) + 
                       " | SHORT: " + format_percent(short_score, 45, 65) + 
                       signal_text + "\n\n" +
                       "📊 FVG Distribution (" + str.tostring(trend_lookback) + " bars)\n" +
                       "Bull: " + format_percent(bullish_percentage, 45, 65) + 
                       " (" + str.tostring(total_bullish_fvgs) + " FVGs)\n" +
                       "Bear: " + format_percent(bearish_percentage, 45, 65) + 
                       " (" + str.tostring(total_bearish_fvgs) + " FVGs)\n\n" +
                       "📈 Volume Dominance\n" +
                       "Bull: " + format_percent(bullish_vol_percentage, 45, 65) + "\n" +
                       "Bear: " + format_percent(bearish_vol_percentage, 45, 65) + "\n\n" +
                       "💪 Volume vs Average\n" +
                       "Bull Vol: " + format_percent(latest_bull_vol_strength, 90, 150) + "\n" +
                       "Bear Vol: " + format_percent(latest_bear_vol_strength, 90, 150) + "\n\n" +
                       "📏 Gap Size/ATR\n" +
                       "Bull: " + format_percent(latest_bull_gap_size, 35, 75) + "\n" +
                       "Bear: " + format_percent(latest_bear_gap_size, 35, 75) + "\n\n" +
                       "🔄 Momentum Strength\n" +  // New metric replacing Fill Rate
                       "Bull: " + format_percent(bull_momentum, 40, 60) + "\n" +
                       "Bear: " + format_percent(bear_momentum, 40, 60)
    
    // Create new label with enhanced metrics
    trend_label := label.new(
         x=x_pos,
         y=y_pos,
         text=label_text,
         color=color.new(color.black, 100),  // Transparent background
         style=trend_label_position == "top right" or trend_label_position == "bottom right" ? label.style_label_left : label.style_label_right,
         textcolor=trend_label_color,
         size=trend_label_size == "tiny" ? size.tiny : trend_label_size == "small" ? size.small : 
              trend_label_size == "normal" ? size.normal : size.large)

// Replace the strong FVG line creation section
if barstate.isconfirmed
    // Check bullish FVGs
    if array.size(bullishBoxes) > 0
        for i = array.size(bullishBoxes) - 1 to 0
            if i < array.size(bullishFVGStartBars) and i < array.size(bullishLineCreated)
                int startBar = array.get(bullishFVGStartBars, i)
                bool hasLine = array.get(bullishLineCreated, i)
                
                if not hasLine and bar_index - startBar >= strong_fvg_bars
                    float bottom = array.get(bullishBottoms, i)
                    line strongLine = line.new(
                         x1=startBar, 
                         y1=bottom, 
                         x2=bar_index + 10, 
                         y2=bottom, 
                         color=strong_bullish_line_color, 
                         width=strong_fvg_line_width,
                         style=(strong_fvg_line_style == "solid" ? line.style_solid : 
                               strong_fvg_line_style == "dashed" ? line.style_dashed : 
                               line.style_dotted))
                    array.push(bullishStrongLines, strongLine)
                    array.push(bullishLineIndices, i)
                    array.set(bullishLineCreated, i, true)
                else if hasLine
                    // Find the corresponding line
                    int lineIndex = array.indexof(bullishLineIndices, i)
                    if lineIndex >= 0 and lineIndex < array.size(bullishStrongLines)
                        line existingLine = array.get(bullishStrongLines, lineIndex)
                        if not na(existingLine)
                            line.set_x2(existingLine, bar_index + 10)
    
    // Check bearish FVGs
    if array.size(bearishBoxes) > 0
        for i = array.size(bearishBoxes) - 1 to 0
            if i < array.size(bearishFVGStartBars) and i < array.size(bearishLineCreated)
                int startBar = array.get(bearishFVGStartBars, i)
                bool hasLine = array.get(bearishLineCreated, i)
                
                if not hasLine and bar_index - startBar >= strong_fvg_bars
                    float top = array.get(bearishTops, i)  // Get the top value from bearishTops array
                    line strongLine = line.new(
                         x1=startBar, 
                         y1=top,  // Use top value for y-coordinates
                         x2=bar_index + 10, 
                         y2=top,  // Use top value for y-coordinates
                         color=strong_bearish_line_color, 
                         width=strong_fvg_line_width,
                         style=(strong_fvg_line_style == "solid" ? line.style_solid : 
                               strong_fvg_line_style == "dashed" ? line.style_dashed : 
                               line.style_dotted))
                    array.push(bearishStrongLines, strongLine)
                    array.push(bearishLineIndices, i)
                    array.set(bearishLineCreated, i, true)
                else if hasLine
                    // Find the corresponding line
                    int lineIndex = array.indexof(bearishLineIndices, i)
                    if lineIndex >= 0 and lineIndex < array.size(bearishStrongLines)
                        line existingLine = array.get(bearishStrongLines, lineIndex)
                        if not na(existingLine)
                            float top = array.get(bearishTops, i)  // Get top value for updating line
                            line.set_x2(existingLine, bar_index + 10)
                            line.set_y1(existingLine, top)  // Ensure y1 is at the top
                            line.set_y2(existingLine, top)  // Ensure y2 is at the top

// Clean up old lines that are no longer needed
if array.size(bullishStrongLines) > max_strong_lines
    line oldLine = array.shift(bullishStrongLines)
    array.shift(bullishLineIndices)
    line.delete(oldLine)

if array.size(bearishStrongLines) > max_strong_lines
    line oldLine = array.shift(bearishStrongLines)
    array.shift(bearishLineIndices)
    line.delete(oldLine)