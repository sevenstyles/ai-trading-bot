// Â© Sevenstyles

//@version=5
indicator(title="Fair Value Gaps", shorttitle="FVG", overlay=true, max_boxes_count = 200)

// Input parameters
ext = input.int(10, "Extend FVGs")

// Trend Strength Settings
trend_lookback = input.int(100, "Trend Strength Lookback", minval=10, maxval=500, group="Trend Strength Settings", tooltip="Number of bars to analyze for trend strength")
trend_label_color = input.color(defval = color.new(color.white, 0), title = "Trend Label Text Color", group = "Trend Strength Settings")
trend_label_size = input.string("large", "Trend Label Size", options=["tiny", "small", "normal", "large"], group="Trend Strength Settings")
trend_label_position = input.string("top right", "Label Position", options=["top right", "top left", "bottom right", "bottom left"], group="Trend Strength Settings")

// Color Settings
upcolor = input.color(defval = color.new(color.green, 77), title = "Bullish color", group = "Aesthetics")
downcolor = input.color(defval = color.new(color.red, 77), title = "Bearish color", group = "Aesthetics")
consecutive_upcolor = input.color(defval = color.new(color.blue, 77), title = "Consecutive Bullish color", group = "Aesthetics")
consecutive_downcolor = input.color(defval = color.new(color.purple, 77), title = "Consecutive Bearish color", group = "Aesthetics")
opposite_signal_color = input.color(defval = color.new(color.blue, 0), title = "Opposite Signal color", group = "Aesthetics")

// Plot size for the circle
plot_size = input.string("small", "Signal Plot Size", options=["tiny", "small", "normal", "large"], group="Aesthetics")

// Function to convert string size to plotshape size
get_plot_size(size_str) =>
    size_str == "tiny" ? size.tiny : size_str == "small" ? size.small : size_str == "normal" ? size.normal : size.large

// Swing Point Settings
swing_lookback = input.int(10, "Swing Point Lookback Period", minval=3, maxval=50, group="Swing Point Settings", tooltip="Number of bars to look back for finding swing points")

// Consecutive FVG Settings
use_consecutive = input.bool(true, "Filter for Consecutive FVGs", group="Consecutive FVG Filter")
required_consecutive = input.int(2, "Required Consecutive FVGs", minval=2, maxval=5, group="Consecutive FVG Filter", tooltip="Only show FVGs when this many consecutive FVGs of the same type (bullish/bearish) have occurred")
highlight_consecutive = input.bool(true, "Highlight Consecutive FVGs", group="Consecutive FVG Filter")

// Candle Color Filter
use_candle_color_filter = input.bool(true, "Filter by Candle Color", group="Candle Color Filter", tooltip="Only show FVGs when all three candles are the same color")

// Arrays to store boxes and their levels
var box[] bullishBoxes = array.new_box()
var float[] bullishTops = array.new_float()
var float[] bullishBottoms = array.new_float()
var box[] bearishBoxes = array.new_box()
var float[] bearishTops = array.new_float()
var float[] bearishBottoms = array.new_float()

// Arrays to store swing labels
var label[] bullishLabels = array.new_label()
var label[] bearishLabels = array.new_label()

// Variables to track consecutive FVGs
var int bullishConsecutive = 0
var int bearishConsecutive = 0
var bool lastWasBullish = false
var bool lastWasBearish = false
var bool bfvg = false
var bool sfvg = false
var bool canPlotFVG = false

// Variables for opposite signal plotting
var bool plot_bullish_signal = false
var bool plot_bearish_signal = false

// Variables for trend strength calculation
var int total_bullish_fvgs = 0
var int total_bearish_fvgs = 0
var label trend_label = na

// Function to check if candle is bullish/bearish
is_bullish_candle(idx) => close[idx] > open[idx]
is_bearish_candle(idx) => close[idx] < open[idx]

// Function to check if three candles are same color
are_three_candles_bullish(idx) =>
    is_bullish_candle(idx) and is_bullish_candle(idx+1) and is_bullish_candle(idx+2)

are_three_candles_bearish(idx) =>
    is_bearish_candle(idx) and is_bearish_candle(idx+1) and is_bearish_candle(idx+2)

// Function to check if three candles form an opposite signal
is_opposite_signal_bullish(idx) =>
    // For bullish FVG: Check if first two candles are bullish and last candle is bearish
    is_bullish_candle(idx+2) and is_bullish_candle(idx+1) and is_bearish_candle(idx)

is_opposite_signal_bearish(idx) =>
    // For bearish FVG: Check if first two candles are bearish and last candle is bullish
    is_bearish_candle(idx+2) and is_bearish_candle(idx+1) and is_bullish_candle(idx)

// FVG Detection with filters
// Only check for FVG after the current candle has closed
if barstate.isconfirmed
    // Check for bullish FVG
    if low > high[2]  // Check the gap using current candle
        if not use_candle_color_filter  // If color filter is off
            bfvg := true
            canPlotFVG := true
            plot_bullish_signal := is_opposite_signal_bullish(0)  // Check for opposite signal pattern
        else if are_three_candles_bullish(0)  // If using color filter, all must be bullish
            bfvg := true
            canPlotFVG := true
            plot_bullish_signal := false  // No opposite signal if all candles must be same color
        else
            bfvg := false
            plot_bullish_signal := false
    else
        bfvg := false
        plot_bullish_signal := false
    
    // Check for bearish FVG
    if high < low[2]  // Check the gap using current candle
        if not use_candle_color_filter  // If color filter is off
            sfvg := true
            canPlotFVG := true
            plot_bearish_signal := is_opposite_signal_bearish(0)  // Check for opposite signal pattern
        else if are_three_candles_bearish(0)  // If using color filter, all must be bearish
            sfvg := true
            canPlotFVG := true
            plot_bearish_signal := false  // No opposite signal if all candles must be same color
        else
            sfvg := false
            plot_bearish_signal := false
    else
        sfvg := false
        plot_bearish_signal := false
else
    bfvg := false
    sfvg := false
    canPlotFVG := false
    plot_bullish_signal := false
    plot_bearish_signal := false

// Update consecutive counters with type checking
if bfvg and lastWasBullish
    bullishConsecutive := bullishConsecutive + 1
else if bfvg
    bullishConsecutive := 1
else
    bullishConsecutive := 0

if sfvg and lastWasBearish
    bearishConsecutive := bearishConsecutive + 1
else if sfvg
    bearishConsecutive := 1
else
    bearishConsecutive := 0

// Update last FVG type
lastWasBullish := bfvg
lastWasBearish := sfvg

// Function to find previous swing high/low
find_swing_point(is_high) =>
    float result = is_high ? high[1] : low[1]
    int point_index = 1
    
    for i = 2 to swing_lookback  // Use the user-defined lookback period
        float curr_value = is_high ? high[i] : low[i]
        if is_high ? (curr_value > result) : (curr_value < result)
            result := curr_value
            point_index := i
    [result, point_index]

// Create new FVG boxes only when candle has closed
if canPlotFVG
    if bfvg and (not use_consecutive or bullishConsecutive >= required_consecutive)
        float fvg_top = low
        float fvg_bottom = high[2]
        
        color boxColor = highlight_consecutive and bullishConsecutive >= required_consecutive ? consecutive_upcolor : upcolor
        box newBox = box.new(left=bar_index-2, top=fvg_top, right=bar_index+ext, bottom=fvg_bottom,
             border_color=color.new(color.gray, 100), bgcolor=boxColor)
        array.push(bullishBoxes, newBox)
        array.push(bullishTops, fvg_top)
        array.push(bullishBottoms, fvg_bottom)
        
        // Add PL label
        [swing_low, low_index] = find_swing_point(false)
        label newLabel = label.new(bar_index-low_index, swing_low, text="PL",
             color=color.new(color.green, 80), textcolor=color.green,
             style=label.style_label_up)
        array.push(bullishLabels, newLabel)

    if sfvg and (not use_consecutive or bearishConsecutive >= required_consecutive)
        float fvg_top = high
        float fvg_bottom = low[2]
        
        color boxColor = highlight_consecutive and bearishConsecutive >= required_consecutive ? consecutive_downcolor : downcolor
        box newBox = box.new(left=bar_index-2, top=fvg_top, right=bar_index+ext, bottom=fvg_bottom,
             border_color=color.new(color.gray, 100), bgcolor=boxColor)
        array.push(bearishBoxes, newBox)
        array.push(bearishTops, fvg_top)
        array.push(bearishBottoms, fvg_bottom)
        
        // Add PH label
        [swing_high, high_index] = find_swing_point(true)
        label newLabel = label.new(bar_index-high_index, swing_high, text="PH",
             color=color.new(color.red, 80), textcolor=color.red,
             style=label.style_label_down)
        array.push(bearishLabels, newLabel)

// Plot the signals at script level
plotshape(plot_bullish_signal, title="Bullish Opposite Signal", 
         style=shape.circle, location=location.abovebar, 
         color=opposite_signal_color, size=size.small)

plotshape(plot_bearish_signal, title="Bearish Opposite Signal", 
         style=shape.circle, location=location.belowbar, 
         color=opposite_signal_color, size=size.small)

// Check for invalidation and remove boxes
if array.size(bullishBoxes) > 0 and barstate.isconfirmed  // Only check on candle close
    for i = array.size(bullishBoxes) - 1 to 0
        box currentBox = array.get(bullishBoxes, i)
        float top = array.get(bullishTops, i)
        float bottom = array.get(bullishBottoms, i)
        label currentLabel = array.get(bullishLabels, i)
        
        // For bullish FVGs, remove only when a bearish candle's ENTIRE body (open and close) is below the FVG zone
        if is_bearish_candle(0) and close < bottom and open < bottom  // Must be a bearish candle with its ENTIRE body below FVG bottom
            box.delete(currentBox)
            label.delete(currentLabel)
            array.remove(bullishBoxes, i)
            array.remove(bullishTops, i)
            array.remove(bullishBottoms, i)
            array.remove(bullishLabels, i)
        else
            box.set_right(currentBox, bar_index + ext)

if array.size(bearishBoxes) > 0 and barstate.isconfirmed  // Only check on candle close
    for i = array.size(bearishBoxes) - 1 to 0
        box currentBox = array.get(bearishBoxes, i)
        float top = array.get(bearishTops, i)
        float bottom = array.get(bearishBottoms, i)
        label currentLabel = array.get(bearishLabels, i)
        
        // For bearish FVGs, remove only when a bullish candle's ENTIRE body (open and close) is above the FVG top
        if is_bullish_candle(0) and close > top and open > top  // Must be a bullish candle with its ENTIRE body above FVG top
            box.delete(currentBox)
            label.delete(currentLabel)
            array.remove(bearishBoxes, i)
            array.remove(bearishTops, i)
            array.remove(bearishBottoms, i)
            array.remove(bearishLabels, i)
        else
            box.set_right(currentBox, bar_index + ext)

// After the box removal checks, calculate and display trend strength
if barstate.isconfirmed
    // Reset counters
    int bullish_count = 0
    int bearish_count = 0
    
    // Count bullish FVGs within lookback period
    if array.size(bullishBoxes) > 0
        for i = 0 to array.size(bullishBoxes) - 1
            box currentBox = array.get(bullishBoxes, i)
            int box_left = box.get_left(currentBox)
            if bar_index - box_left <= trend_lookback
                bullish_count += 1
    
    // Count bearish FVGs within lookback period
    if array.size(bearishBoxes) > 0
        for i = 0 to array.size(bearishBoxes) - 1
            box currentBox = array.get(bearishBoxes, i)
            int box_left = box.get_left(currentBox)
            if bar_index - box_left <= trend_lookback
                bearish_count += 1
    
    // Update totals
    total_bullish_fvgs := bullish_count
    total_bearish_fvgs := bearish_count
    
    // Calculate percentages
    float total_fvgs = total_bullish_fvgs + total_bearish_fvgs
    float bullish_percentage = total_fvgs > 0 ? (total_bullish_fvgs / total_fvgs) * 100 : 0
    float bearish_percentage = total_fvgs > 0 ? (total_bearish_fvgs / total_fvgs) * 100 : 0
    
    // Delete old label
    if not na(trend_label)
        label.delete(trend_label)
    
    // Determine label position
    int x_pos = trend_label_position == "top right" or trend_label_position == "bottom right" ? bar_index + 2 : bar_index - 50
    float y_pos = trend_label_position == "top right" or trend_label_position == "top left" ? ta.highest(high, 20) * 1.02 : ta.lowest(low, 20) * 0.98
    
    // Create label text with proper formatting
    string label_text = "Lookback: " + str.tostring(trend_lookback) + " bars\n" +
                       "Bullish FVGs: " + str.tostring(total_bullish_fvgs) + " (" + str.tostring(bullish_percentage, "#.##") + "%)\n" +
                       "Bearish FVGs: " + str.tostring(total_bearish_fvgs) + " (" + str.tostring(bearish_percentage, "#.##") + "%)"
    
    // Create new label with percentages
    trend_label := label.new(
         x=x_pos,
         y=y_pos,
         text=label_text,
         color=color.new(color.black, 100),  // Transparent background
         style=trend_label_position == "top right" or trend_label_position == "bottom right" ? label.style_label_left : label.style_label_right,
         textcolor=trend_label_color,
         size=trend_label_size == "tiny" ? size.tiny : trend_label_size == "small" ? size.small : 
              trend_label_size == "normal" ? size.normal : size.large)