// Â© Sevenstyles

//@version=5
indicator(title="Fair Value Gaps", shorttitle="FVG", overlay=true, max_boxes_count = 200)

// Input parameters
ext = input.int(10, "Extend FVGs")

// Color Settings
upcolor = input.color(defval = color.green, title = "Bullish color", group = "Aesthetics")
downcolor = input.color(defval = color.red, title = "Bearish color", group = "Aesthetics")
consecutive_upcolor = input.color(defval = color.new(color.blue, 15), title = "Consecutive Bullish color", group = "Aesthetics")
consecutive_downcolor = input.color(defval = color.new(color.purple, 15), title = "Consecutive Bearish color", group = "Aesthetics")

// Candle Size Filter
use_candle_filter = input.bool(true, "Filter by Candle Size", group="Candle Size Filter")
candle_multiplier = input.float(2.0, "Candle must be X times bigger", minval=1.0, step=0.1, group="Candle Size Filter")
lookback_periods = input.int(5, "Compare with previous X candles", minval=1, maxval=50, group="Candle Size Filter")

// Swing Point Settings
swing_lookback = input.int(10, "Swing Point Lookback Period", minval=3, maxval=50, group="Swing Point Settings", tooltip="Number of bars to look back for finding swing points")

// Consecutive FVG Settings
use_consecutive = input.bool(true, "Filter for Consecutive FVGs", group="Consecutive FVG Filter")
required_consecutive = input.int(2, "Required Consecutive FVGs", minval=2, maxval=5, group="Consecutive FVG Filter", tooltip="Only show FVGs when this many consecutive FVGs of the same type (bullish/bearish) have occurred")
highlight_consecutive = input.bool(true, "Highlight Consecutive FVGs", group="Consecutive FVG Filter")

// Arrays to store boxes and their levels
var box[] bullishBoxes = array.new_box()
var float[] bullishTops = array.new_float()
var float[] bullishBottoms = array.new_float()
var box[] bearishBoxes = array.new_box()
var float[] bearishTops = array.new_float()
var float[] bearishBottoms = array.new_float()

// Arrays to store swing labels
var label[] bullishLabels = array.new_label()
var label[] bearishLabels = array.new_label()

// Variables to track consecutive FVGs
var int bullishConsecutive = 0
var int bearishConsecutive = 0
var bool lastWasBullish = false
var bool lastWasBearish = false

// Function to check if candle is significantly larger than previous candles
is_significant_candle(index) =>
    current_size = math.abs(high[index] - low[index])
    avg_prev_size = 0.0
    for i = 1 to lookback_periods
        avg_prev_size += math.abs(high[index + i] - low[index + i])
    avg_prev_size := avg_prev_size / lookback_periods
    not use_candle_filter or current_size >= (avg_prev_size * candle_multiplier)

// FVG Detection with filters
bfvg = low > high[2] and is_significant_candle(2)
sfvg = high < low[2] and is_significant_candle(2)

// Update consecutive counters with type checking
if bfvg and lastWasBullish
    bullishConsecutive := bullishConsecutive + 1
else if bfvg
    bullishConsecutive := 1
else
    bullishConsecutive := 0

if sfvg and lastWasBearish
    bearishConsecutive := bearishConsecutive + 1
else if sfvg
    bearishConsecutive := 1
else
    bearishConsecutive := 0

// Update last FVG type
lastWasBullish := bfvg
lastWasBearish := sfvg

// Function to find previous swing high/low
find_swing_point(is_high) =>
    float result = is_high ? high[2] : low[2]
    int point_index = 2
    
    for i = 3 to swing_lookback  // Use the user-defined lookback period
        float curr_value = is_high ? high[i] : low[i]
        if is_high ? (curr_value > result) : (curr_value < result)
            result := curr_value
            point_index := i
    [result, point_index]

// Create new FVG boxes
if bfvg and (not use_consecutive or bullishConsecutive >= required_consecutive)
    float fvg_top = low
    float fvg_bottom = high[2]
    
    color boxColor = highlight_consecutive and bullishConsecutive >= required_consecutive ? consecutive_upcolor : upcolor
    box newBox = box.new(left=bar_index-2, top=fvg_top, right=bar_index+ext, bottom=fvg_bottom,
         border_color=color.new(color.gray, 100), bgcolor=boxColor)
    array.push(bullishBoxes, newBox)
    array.push(bullishTops, fvg_top)
    array.push(bullishBottoms, fvg_bottom)
    
    // Add PL label
    [swing_low, low_index] = find_swing_point(false)
    label newLabel = label.new(bar_index-low_index, swing_low, text="PL",
         color=color.new(color.green, 80), textcolor=color.green,
         style=label.style_label_up)
    array.push(bullishLabels, newLabel)

if sfvg and (not use_consecutive or bearishConsecutive >= required_consecutive)
    float fvg_top = high
    float fvg_bottom = low[2]
    
    color boxColor = highlight_consecutive and bearishConsecutive >= required_consecutive ? consecutive_downcolor : downcolor
    box newBox = box.new(left=bar_index-2, top=fvg_top, right=bar_index+ext, bottom=fvg_bottom,
         border_color=color.new(color.gray, 100), bgcolor=boxColor)
    array.push(bearishBoxes, newBox)
    array.push(bearishTops, fvg_top)
    array.push(bearishBottoms, fvg_bottom)
    
    // Add PH label
    [swing_high, high_index] = find_swing_point(true)
    label newLabel = label.new(bar_index-high_index, swing_high, text="PH",
         color=color.new(color.red, 80), textcolor=color.red,
         style=label.style_label_down)
    array.push(bearishLabels, newLabel)

// Check for invalidation and remove boxes
if array.size(bullishBoxes) > 0
    for i = array.size(bullishBoxes) - 1 to 0
        box currentBox = array.get(bullishBoxes, i)
        float bottom = array.get(bullishBottoms, i)
        label currentLabel = array.get(bullishLabels, i)
        if close < bottom
            box.delete(currentBox)
            label.delete(currentLabel)
            array.remove(bullishBoxes, i)
            array.remove(bullishTops, i)
            array.remove(bullishBottoms, i)
            array.remove(bullishLabels, i)
        else
            box.set_right(currentBox, bar_index + ext)

if array.size(bearishBoxes) > 0
    for i = array.size(bearishBoxes) - 1 to 0
        box currentBox = array.get(bearishBoxes, i)
        float top = array.get(bearishTops, i)
        label currentLabel = array.get(bearishLabels, i)
        if close > top
            box.delete(currentBox)
            label.delete(currentLabel)
            array.remove(bearishBoxes, i)
            array.remove(bearishTops, i)
            array.remove(bearishBottoms, i)
            array.remove(bearishLabels, i)
        else
            box.set_right(currentBox, bar_index + ext)